{"name":"Django-restroom","tagline":"super lightweight django read-only REST api framework","body":"# Django-EasyRest\r\nEasyRest is a lightweight framework (less than 160 lines of code!) that allows you to really quickly and flexibly create a READ-ONLY REST API for your models.\r\n\r\n## Table of Contents\r\n\r\n* [Why use EasyRest?](#why-use-easyrest)\r\n* [EasyRest vs. other frameworks?](#easyrest-vs-other-frameworks)\r\n* [Features](#features)\r\n* [Installation](#installation)\r\n* [Usage](#usage)\r\n  * [Declaring a Resource](#declaring-a-resource)\r\n  * [Registering to the API](#registering-to-the-api)\r\n  * [Format of Requests and Responses](#format-of-requests-and-responses)\r\n  * [Pagination](#pagination)\r\n  * [Search](#search)\r\n  * [Authentication](#authentication)\r\n  * [Restricting by Owner](#restricting-by-owner)\r\n* [How to Extend EasyRest](#how-to-extend-easyrest)\r\n* [How to Hack on EasyRest](#how-to-extend-easyrest)\r\n* [Roadmap](#roadmap)\r\n* [Development](#development)\r\n  * [License](#license)\r\n\r\n## Why use EasyRest?\r\n* You need a simple read-only REST API for your Backbone/similar app\r\n* You need a read-only API for others to consume. Did you know EasyRest has a simple and extensible authentication system?\r\n\r\n## EasyRest vs. other frameworks?\r\nIn exchange for full-featuredness, those other frameworks are hard to setup and use.\r\nEasyRest is really simple to use and even simpler to extend.\r\n\r\n## Features\r\nEasyRest is meant to be simple and cover the most common use cases. So it supports,\r\n* pagination\r\n* authentication\r\n* restricting by owner\r\n* search\r\n\r\n## Installation\r\n```\r\npip install django-easyrest\r\n```\r\n\r\n## Usage\r\n```python\r\n# api.py\r\n\r\nfrom easyrest import API\r\nfrom .models import Item\r\n\r\napi = API()\r\n\r\nclass ItemResource(APIResource):\r\n    model = Item\r\n    name = 'item'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\napi.register(ItemResource)\r\n\r\n# urls.py\r\nfrom django.conf.urls import url, patterns, include\r\nfrom .api import api\r\n\r\nurlpatterns = patterns('', url(r'^api/', include(api.get_urls())))\r\n```\r\n## Declaring a Resource\r\nYou only need to specify 3 things when subclassing APIResource:\r\n\r\n1. `model`: the Django model you're exposing through the API\r\n2. `name`: this is the name of resource in the url: '/api/{{ name }}/'. If you don't set it, it will fallback to the Model.meta.db_table\r\n3. `serialize` method: returns a serialized version of an instance of your Model, however you want it to. You can reference properties and whatever else. You're not just limited to the model fields.\r\n\r\nYou can also specify the `get_queryset` method, which will return the base queryset that will be used in the item-list endpoint as well as the search endpoint.\r\nSo if you wanted to have the queryset ordered by `id` descending and `status > 7`, you would add to the above `ItemResource` the following method:\r\n\r\n```python\r\n    def get_queryset(self):\r\n        return Item.objects.filter(status__gt=7).order_by('-id')\r\n```\r\n\r\nUse this method to customize the set of results you want returned any way you like.\r\nFor example, you can do preprocessing as we did above with the `status` as well as specify an ordering.\r\n\r\n## Registering to the api\r\n\r\n* Create an instance of `easyrest.API`\r\n* Then register your resource: `api.register(MyResource)`\r\n* Then include `api.get_urls` in your urlconf\r\n\r\nNote that because you are registering resources with an instance of `easyrest.API`, you can conceivably have many different API instances with different resources. EasyRest is flexible in how you use it.\r\n\r\n## Format of Requests and Responses\r\nLet's use the example of ItemResource above.\r\nThe urls generated are:\r\n    * /api/item/ - This returns a list of Items\r\n    * /api/item/{int: id}/ - This returns a single serialized Item with the specified id\r\n\r\n### GET to the Item list endpoint\r\n```python\r\nGET /api/item/ 200\r\n\r\n{\r\n   \"items\": [\r\n       {\r\n           \"id\": 1,\r\n           \"name\": \"Louis CK\"\r\n           \"text\": \"I'm a hilarious comedian\",\r\n           \"popularity\": 99,\r\n       },\r\n       {\r\n           \"id\": 2,\r\n           \"name\": \"Joffrey Lannister\",\r\n           \"text\": \"I'm troubled.\",\r\n           \"popularity\": 2,\r\n       }\r\n    ]\r\n}\r\n```\r\n\r\n### GET to the Item single-item endpoint\r\n```python\r\nGET /api/item/1/ 200\r\n\r\n{\r\n    \"id\": 1,\r\n    \"name\": \"Louis CK\"\r\n    \"text\": \"I'm a hilarious comedian\",\r\n    \"popularity\": 99,\r\n}\r\n```\r\n\r\n### GET to the Item single-item endpoint for a nonexistent item\r\n```python\r\nGET /api/item/9998/ 400\r\n\r\n{\r\n    \"error\": \"No result found matching id: 9998\"\r\n}\r\n```\r\n\r\n## Pagination\r\nIf you want to paginate the results, you just need to set `results_per_page`. Here's an example:\r\n\r\n```python\r\nclass PaginatedItemResource(APIResource):\r\n    model = Item\r\n    name = 'paginated_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n```\r\nIf you don't set `results_per_page`, all of the items will be returned at once.\r\n\r\n### How do I request a paginated resource?\r\nSimple.\r\n```\r\nGET /api/item/?page=2\r\n```\r\n\r\n\r\n## Search\r\n\r\nSometimes you might want to allow your API user to search for a result set rather than just listing the results in a certain order.\r\nThe way to set this up in EasyRest is intentionally very barebones so you can extend it and implement the search you want for your resource, no matter how simple or complicated.\r\n\r\n### Define the `search` method\r\n```python\r\nclass SearchableItemResource(APIResource):\r\n    model = Item\r\n    name = 'searchable_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\n    def search(self, get_params):\r\n        \"\"\"\r\n        Some custom search logic.\r\n        You always have access to the request.GET params\r\n        through `get_params`\r\n        \"\"\"\r\n        filter_kwargs = {}\r\n        if get_params.get(\"popular\"):\r\n            filter_kwargs[\"popularity__gte\"] = 9\r\n         \r\n        if get_params.get(\"contains\"):\r\n            filter_kwargs[\"text__icontains\"] = get_params[\"contains\"]\r\n        return self.get_queryset().filter(**filter_kwargs)\r\n```\r\n\r\nThe important thing here is you can plug in whatever search system you want. You're not even tied to SQL or the Django ORM. You can use ElasticSearch or whatever backend makes sense for your use case. You just have to define the `search` method that takes a dictionary of request GET params.\r\n\r\n### Make a search request\r\nThe URL will be \"/{resource name}/search/\"\r\nThe format of the request will depend on how you implement the `search` method, but in this case, it looks like this:\r\n\r\n`GET /api/searchable_item/search/?popular=1&contains=fun`\r\n\r\n## Authentication\r\nEasyRest Authentication is really easy to use and extend, as you'll see below.\r\n\r\n### 1. Define an authorization scheme\r\nDecide whether you want your API consumer to pass in an API key through the request GET parameters or the headers or whatever else.\r\n\r\n### 2. Set `needs_authentication = True` in your resource declaration\r\n\r\n### 3. Define an `authorize` method for your resource\r\nOften you may want the same authorization method for many of your resources.\r\nIn that case, you should subclass APIResource and define the `authorize` method, let's call it AuthorizedAPIResource.\r\n\r\nThen, all of your model resources can subclass AuthorizedAPIResource.\r\n\r\n### Here's an example:\r\n\r\n```python\r\nfrom resteasy.resources import APIResource\r\nfrom resteasy.auth import get_user_from_GET_param\r\n\r\nclass AuthorizedAPIResource(APIResource):\r\n    \"\"\"\r\n    I subclass APIResource and implement the authorize method.\r\n    Many of my resources will require this authorization, so they\r\n    will inherit from this class.\r\n    \"\"\"\r\n    def authorize(self, request):\r\n        \"\"\"\r\n        I find the user based on the value of `apikey`\r\n        being passed in as a GET parameter.\r\n        \"\"\"\r\n        return get_user_from_GET_param(request, \"apikey\")\r\n\r\n\r\nclass AuthorizedItemResource(AuthorizedAPIResource):\r\n    model = UserItem\r\n    name = 'authorized_item'\r\n    needs_authentication = True\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\nAn example request would be `GET /api/authorized_item/?apikey=kjhsdf3`\r\n\r\n### Authorization helper methods\r\nIn easyrest.auth, there are three really useful helper methods:\r\n\r\n1. `get_user_from_GET_param(request, param_name)`: extracts API key from the request GET parameter `param_name` and returns the user who owns that API key.\r\n2. `get_user_from_from_request_header`: does the same but from the request header\r\n3. `get_user_from_request`: returns `request.user` if the user is authenticated\r\n\r\nThese are by no means exhaustive, but they do cover a lot of the ways in which you'll want you're API consumers to authenticate.\r\n\r\nIf you want to use your own way of authenticating, just write your own `authorize` method, and you're good.\r\n\r\n### What happens if an unauthorized person tries to access a protected resource?\r\nIf someone tries to access a resource without authorization, they will get a 403 Forbidden response.\r\n\r\n## Restricting by Owner\r\nA lot of the time, we want our API consumers to only access the results that they own.\r\n\r\nImagine an API you can use to get all your Bank Transactions. You want some way of limiting the API user to only retrieving their own bank transactions, so they don't have access to everyone's bank transactions.\r\n\r\nTo achieve this, you just need to do 1 thing in addition to setting up Authentication as above.\r\n### Set `restrict_by_user`\r\nWhen you declare your resource, you should set `restrict_by_user` equal to the field path to the User field corresponding to the owner, the same path you would use through the Django Queryset API.\r\n\r\nIf your UserItem is linked to a User through the field \"user\", for example:\r\n```python\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    user = models.ForeignKey('auth.User')\r\n    is_active = models.BooleanField(default=False)\r\n```\r\nYou should set `restrict_by_user=\"user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    restrict_by_user = 'user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\n#### A more complicated example\r\n\r\n```python\r\nclass Profile(models.Model):\r\n    owner = models.ForeignKeyField('auth.User')\r\n\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    profile = models.ForeignKeyField(Profile)\r\n    is_active = models.BooleanField(default=False)\r\n```\r\n\r\nYou should set `restrict_by_user=\"profile__user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    restrict_by_user = 'profile__user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\n## How to Extend EasyRest\r\nYou may have custom needs for your api. Here's some advice on how to extend EasyRest to meet those needs.\r\n\r\n* If you want to modify what the URLs look like, you should subclass `easyrest.API` and use that subclass as your API.\r\n* If you want to modify how results are retrieved, subclass `APIResource` and modify the `get_list` and `get_one` methods\r\n* If you want to add POST, CREATE or UPDATE funcionality, subclass the views and use those views in your `get_urls` method (to do that would have to subclass API, as mentioned above). In addition, you'll probably want to add methods to `APIResource` to deal with those CRUD operations.\r\n* If you want to plug in a different authentication/authorization scheme, define the `authorize` method of the APIResource.\r\n\r\nThese are just a few guidelines. If you modify it in other cool ways, please let me know, I'd be excited to learn!\r\n\r\nThe *main point* is that since there are only 160 lines of code, you can see the inner workings of this library really easily and feel free to bend it to your will!\r\n\r\n## How to Hack on EasyRest\r\n1. git clone this repo\r\n2. create a virtualenv and install the requirements via `pip install -r requirements.txt`\r\n3. under /tests, run `python manage.py syncdb`\r\n4. to run the tests, in the root directory run `make test`\r\n\r\nHappy hacking!\r\n\r\n\r\n## Roadmap\r\nI'm thinking about whether to support the other CRUD operations.\r\nIf you have any suggestions, please let me know.\r\n\r\n\r\n## Development\r\n### License\r\n\r\n(The MIT license)\r\n\r\nCopyright (c) 2013 Suneel Chakravorty <suneel0101@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}