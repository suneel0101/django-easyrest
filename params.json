{"name":"Django-restroom","tagline":"A super lightweight django REST api framework","body":"# Django-EasyRest\r\n\r\n## What is EasyRest?\r\nEasyRest is a lightweight framework (less than 160 lines of code!) that allows you to really quickly and flexibly create a READ-ONLY REST API for your models.\r\n\r\n## Why would I want to use EasyRest?\r\n* You need a simple read-only REST API for your Backbone/similar app\r\n* You need a read-only API for others to consume. Did you know EasyRest has a simple and extensible authentication system?\r\n\r\n## What about those other frameworks?\r\nIn exchange for full-featuredness, those other frameworks are hard to setup and use.\r\nEasyRest is really simple to use and even simpler to extend.\r\n\r\n## What features do I get with EasyRest?\r\nEasyRest is meant to be simple and cover the most common use cases. So it supports,\r\n* pagination\r\n* authentication\r\n* restricting by owner\r\n* search\r\n\r\n## How do I install it?\r\n```\r\npip install django-easyrest\r\n```\r\n\r\n## How do I use it?\r\n```\r\n# api.py\r\n\r\nfrom easyrest import API\r\nfrom .models import Item\r\n\r\napi = API()\r\n\r\nclass ItemResource(APIResource):\r\n    model = Item\r\n    name = 'item'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\napi.register(ItemResource)\r\n\r\n# urls.py\r\nfrom django.conf.urls import url, patterns, include\r\nfrom .api import api\r\n\r\nurlpatterns = patterns('', url(r'^api/', include(api.get_urls())))\r\n```\r\n## Declaring a Resource\r\nYou only need to specify 3 things when subclassing APIResource:\r\n\r\n1. `model`: the Django model you're exposing through the API\r\n2. `name`: this is the name of resource in the url: '/api/{{ name }}/'. If you don't set it, it will fallback to the Model.meta.db_table\r\n3. `serialize` method: returns a serialized version of an instance of your Model, however you want it to. You can reference properties and whatever else. You're not just limited to the model fields.\r\n\r\n### You can also specify the `get_queryset` method\r\n\r\n## Registering your resource to the api\r\n\r\n    * Create an instance of `easyrest.API`\r\n    * Then register your resource: `api.register(MyResource)`\r\n    * Then include `api.get_urls` in your urlconf\r\n\r\nNote that because you are registering resources with an instance of `easyrest.API`, you can conceivably have many different API instances with different resources. EasyRest is flexible in how you use it.\r\n\r\n## Format of Requests and Responses\r\nLet's use the example of ItemResource above.\r\nThe urls generated are:\r\n    * /api/item/ - This returns a list of Items\r\n    * /api/item/{int: id}/ - This returns a single serialized Item with the specified id\r\n\r\n### GET to the Item list endpoint\r\n```\r\nGET /api/item/ 200\r\n\r\n{\r\n   \"items\": [\r\n       {\r\n           \"id\": 1,\r\n           \"name\": \"Louis CK\"\r\n           \"text\": \"I'm a hilarious comedian\",\r\n           \"popularity\": 99,\r\n       },\r\n       {\r\n           \"id\": 2,\r\n           \"name\": \"Joffrey Lannister\",\r\n           \"text\": \"I'm troubled.\",\r\n           \"popularity\": 2,\r\n       }\r\n    ]\r\n}\r\n```\r\n\r\n### GET to the Item single-item endpoint\r\n```\r\nGET /api/item/1/ 200\r\n\r\n{\r\n    \"id\": 1,\r\n    \"name\": \"Louis CK\"\r\n    \"text\": \"I'm a hilarious comedian\",\r\n    \"popularity\": 99,\r\n}\r\n```\r\n\r\n### GET to the Item single-item endpoint for a nonexistent item\r\n```\r\nGET /api/item/9998/ 400\r\n\r\n{\r\n    \"error\": \"No result found matching id: 9998\"\r\n}\r\n```\r\n\r\n## Pagination\r\nIf you want to paginate the results, you just need to set `results_per_page`. Here's an example:\r\n\r\n```python\r\nclass PaginatedItemResource(APIResource):\r\n    model = Item\r\n    name = 'paginated_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n```\r\nIf you don't set `results_per_page`, all of the items will be returned at once.\r\n\r\n### How do I request a paginated resource?\r\nSimple.\r\n```\r\nGET /api/item/?page=2\r\n```\r\n\r\n\r\n## Search\r\n\r\nSometimes you might want to allow your API user to search for a result set rather than just listing the results in a certain order.\r\nThe way to set this up in EasyRest is intentionally very barebones so you can extend it and implement the search you want for your resource, no matter how simple or complicated.\r\n\r\n### Define the `search` method\r\n```\r\nclass SearchableItemResource(APIResource):\r\n    model = Item\r\n    name = 'searchable_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\n    def search(self, get_params):\r\n        \"\"\"\r\n        Some custom search logic.\r\n        You always have access to the request.GET params\r\n        through `get_params`\r\n        \"\"\"\r\n        filter_kwargs = {}\r\n        if get_params.get(\"popular\"):\r\n            filter_kwargs[\"popularity__gte\"] = 9\r\n         \r\n        if get_params.get(\"contains\"):\r\n            filter_kwargs[\"text__icontains\"] = get_params[\"contains\"]\r\n        return self.get_queryset().filter(**filter_kwargs)\r\n```\r\n\r\nThe important thing here is you can plug in whatever search system you want. You're not even tied to SQL or the Django ORM. You can use ElasticSearch or whatever backend makes sense for your use case. You just have to define the `search` method that takes a dictionary of request GET params.\r\n\r\n### Make a search request\r\nThe URL will be \"/{resource name}/search/\"\r\nThe format of the request will depend on how you implement the `search` method, but in this case, it looks like this:\r\n\r\n`GET /api/searchable_item/search/?popular=1&contains=fun`\r\n\r\n## Authentication\r\nEasyRest Authentication is really easy to use and extend, as you'll see below.\r\n\r\n### 1. Define an authorization scheme\r\nDecide whether you want your API consumer to pass in an API key through the request GET parameters or the headers or whatever else.\r\n\r\n### 2. Set `needs_authentication = True` in your resource declaration\r\n\r\n### 3. Define an `authorize` method for your resource\r\nOften you may want the same authorization method for many of your resources.\r\nIn that case, you should subclass APIResource and define the `authorize` method, let's call it AuthorizedAPIResource.\r\n\r\nThen, all of your model resources can subclass AuthorizedAPIResource.\r\n\r\n### Here's an example:\r\n\r\n```python\r\nfrom resteasy.resources import APIResource\r\nfrom resteasy.auth import get_user_from_GET_param\r\n\r\nclass AuthorizedAPIResource(APIResource):\r\n    \"\"\"\r\n    I subclass APIResource and implement the authorize method.\r\n    Many of my resources will require this authorization, so they\r\n    will inherit from this class.\r\n    \"\"\"\r\n    def authorize(self, request):\r\n        \"\"\"\r\n        I find the user based on the value of `apikey`\r\n        being passed in as a GET parameter.\r\n        \"\"\"\r\n        return get_user_from_GET_param(request, \"apikey\")\r\n\r\n\r\nclass AuthorizedItemResource(AuthorizedAPIResource):\r\n    model = UserItem\r\n    name = 'authorized_item'\r\n    needs_authentication = True\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\nAn example request would be `GET /api/authorized_item/?apikey=kjhsdf3`\r\n\r\n### Authorization helper methods\r\nIn easyrest.auth, there are three really useful helper methods:\r\n\r\n1. `get_user_from_GET_param(request, param_name)`: extracts API key from the request GET parameter `param_name` and returns the user who owns that API key.\r\n2. `get_user_from_from_request_header`: does the same but from the request header\r\n3. `get_user_from_request`: returns `request.user` if the user is authenticated\r\n\r\nThese are by no means exhaustive, but they do cover a lot of the ways in which you'll want you're API consumers to authenticate.\r\n\r\nIf you want to use your own way of authenticating, just write your own `authorize` method, and you're good.\r\n\r\n### What happens if an unauthorized person tries to access a protected resource?\r\nIf someone tries to access a resource without authorization, they will get a 403 Forbidden response.\r\n\r\n## Restricting by Owner\r\nA lot of the time, we want our API consumers to only access the results that they own.\r\n\r\nImagine an API you can use to get all your Bank Transactions. You want some way of limiting the API user to only retrieving their own bank transactions, so they don't have access to everyone's bank transactions.\r\n\r\nTo achieve this, you just need to do 1 thing in addition to setting up Authentication as above.\r\n### Set `restrict_by_user`\r\nWhen you declare your resource, you should set `restrict_by_user` equal to the field path to the User field corresponding to the owner, the same path you would use through the Django Queryset API.\r\n\r\nIf your UserItem is linked to a User through the field \"user\", for example:\r\n```python\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    user = models.ForeignKey('auth.User')\r\n    is_active = models.BooleanField(default=False)\r\n```\r\nYou should set `restrict_by_user=\"user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    restrict_by_user = 'user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\n#### A more complicated example\r\n\r\n```python\r\nclass Profile(models.Model):\r\n    owner = models.ForeignKeyField('auth.User')\r\n\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    profile = models.ForeignKeyField(Profile)\r\n    is_active = models.BooleanField(default=False)\r\n```\r\n\r\nYou should set `restrict_by_user=\"profile__user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    restrict_by_user = 'profile__user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\n## How to Extend EasyRest\r\n## How to Hack on EasyRest\r\n## Roadmap\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}