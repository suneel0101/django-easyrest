{"name":"Django-EasyRest","tagline":"an ultra-lightweight read-only REST api framework for Django","body":"# Django-EasyRest\r\nEasyRest is an ultra-lightweight (160 LOC) read-only REST api framework for Django.\r\n\r\n# Table of Contents\r\n\r\n* [Installation](#installation)\r\n* [Example](#example)\r\n* [Features](#features)\r\n* [When should I use EasyRest?](#when-should-i-use-easyrest)\r\n* [Usage](#usage)\r\n  * [Declare a Resource](#declare-a-resource)\r\n  * [Register the Resource with the API](#register-the-resource-with-the-api)\r\n  * [URL Endpoints](#url-endpoints)\r\n  * [Format of Requests and Responses](#format-of-requests-and-responses)\r\n  * [Enable Pagination](#enable-pagination)\r\n  * [Enable Search](#enable-search)\r\n  * [Use Authentication](#use-authentication)\r\n  * [Authorization Helpers](#authorization-helpers)\r\n  * [Restrict Results by User](#restrict-results-by-user)\r\n* [Bend EasyRest to Your Will](#bend-easyrest-to-your-will)\r\n* [How to Hack on EasyRest](#how-to-hack-on-easyrest)\r\n* [Roadmap](#roadmap)\r\n* [License](#license)\r\n\r\n# Installation<a name=\"installation\">&nbsp;</a>\r\n```\r\npip install django-easyrest\r\n```\r\n\r\n# Example<a name=\"example\">&nbsp;</a>\r\n```python\r\n# api.py\r\n\r\nfrom easyrest import API, APIResource\r\nfrom .models import Item\r\n\r\napi = API()\r\n\r\nclass ItemResource(APIResource):\r\n    model = Item\r\n    name = 'item'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\napi.register(ItemResource)\r\n\r\n# urls.py\r\nfrom django.conf.urls import url, patterns, include\r\nfrom .api import api\r\n\r\nurlpatterns = patterns('', url(r'^api/', include(api.get_urls())))\r\n```\r\n\r\n# Features<a name=\"features\">&nbsp;</a>\r\nEasyRest is meant to be simple and cover the most common use cases. So it supports,\r\n* pagination\r\n* authentication\r\n* restricting by owner\r\n* search\r\n\r\n# When should I use EasyRest?<a name=\"when-should-i-use-easyrest\">&nbsp;</a>\r\n* When you need a simple read-only REST API for your own Backbone/Ember/Angular app\r\n* When you need a read-only API for others to consume - EasyRest has a simple and extensible authentication system.\r\n* Whenever you want!\r\n\r\n# Usage<a name=\"usage\">&nbsp;</a>\r\n## Declare a Resource<a name=\"declare-a-resource\">&nbsp;</a>\r\nYou only need to specify 3 things when subclassing APIResource:\r\n\r\n1. `model`: the Django model you're exposing through the API\r\n2. `name`: this is the name of resource in the url: '/api/{{ name }}/'. If you don't set it, it will fallback to the Model.meta.db_table\r\n3. `serialize` method: returns a serialized version of an instance of your Model, however you want it to. You can reference properties and whatever else. You're not just limited to the model fields.\r\n\r\nYou can also specify the `get_queryset` method, which will return the base queryset that will be used in the item-list endpoint as well as the search endpoint.\r\nSo if you wanted to have the queryset ordered by `id` descending and `status > 7`, you would add to the above `ItemResource` the following method:\r\n\r\n```python\r\n    def get_queryset(self):\r\n        return Item.objects.filter(status__gt=7).order_by('-id')\r\n```\r\n\r\nUse this method to customize the set of results you want returned any way you like.\r\nFor example, you can do preprocessing as we did above with the `status` as well as specify an ordering.\r\n\r\n## Register the Resource with the API<a name=\"register-the-resource-with-the-api\">&nbsp;</a>\r\n\r\n* Create an instance of `easyrest.API`\r\n* Then register your resource: `api.register(MyResource)`\r\n* Then include `api.get_urls` in your urlconf\r\n\r\nNote that because you are registering resources with an instance of `easyrest.API`, you can conceivably have many different API instances with different resources. EasyRest is flexible in how you use it.\r\n\r\n## URL Endpoints<a name=\"url-endpoints\">&nbsp;</a>\r\n\r\n\r\nFor each resource you register, there are two URL endpoints: the list endpoint and the item endpoint.\r\nThe list endpoint returns a list of instances.\r\nThe item endpoint returns a single instance.\r\n\r\n\r\nLet's use the example of ItemResource above.\r\nWe named the resource \"item\" and included the api urls behind the prefix \"/api\".\r\nSo, the urls generated are:\r\n\r\n\r\n* `/api/item/` - This returns a list of Items\r\n* `/api/item/{int: id}/` - This returns a single serialized Item with the specified id\r\n\r\n\r\n## Format of Requests and Responses<a name=\"format-of-requests-and-responses\">&nbsp;</a>\r\n\r\n#### GET to the Item list endpoint\r\n```python\r\nGET /api/item/ 200\r\n\r\n{\r\n   \"items\": [\r\n       {\r\n           \"id\": 1,\r\n           \"name\": \"Louis CK\"\r\n           \"text\": \"I'm a hilarious comedian\",\r\n           \"popularity\": 99,\r\n       },\r\n       {\r\n           \"id\": 2,\r\n           \"name\": \"Joffrey Lannister\",\r\n           \"text\": \"I'm troubled.\",\r\n           \"popularity\": 2,\r\n       }\r\n    ]\r\n}\r\n```\r\n\r\n#### GET to the Item single-item endpoint\r\n```python\r\nGET /api/item/1/ 200\r\n\r\n{\r\n    \"id\": 1,\r\n    \"name\": \"Louis CK\"\r\n    \"text\": \"I'm a hilarious comedian\",\r\n    \"popularity\": 99,\r\n}\r\n```\r\n\r\n#### GET to the Item single-item endpoint for a nonexistent item\r\n```python\r\nGET /api/item/9998/ 400\r\n\r\n{\r\n    \"error\": \"No result found matching id: 9998\"\r\n}\r\n```\r\n\r\n## Enable Pagination<a name=\"enable-pagination\">&nbsp;</a>\r\nIf you want to paginate the results, you just need to set `results_per_page`. Here's an example:\r\n\r\n```python\r\nclass PaginatedItemResource(APIResource):\r\n    model = Item\r\n    name = 'paginated_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n```\r\nIf you don't set `results_per_page`, all of the items will be returned at once.\r\n\r\n#### How do I request a paginated resource?\r\nSimple.\r\n```\r\nGET /api/item/?page=2\r\n```\r\n\r\n\r\n## Enable Search<a name=\"enable-search\">&nbsp;</a>\r\n\r\nSometimes you might want to allow your API user to search for a result set rather than just listing the results in a certain order.\r\nThe way to set this up in EasyRest is intentionally very barebones so you can extend it and implement the search you want for your resource, no matter how simple or complicated.\r\n\r\n#### All you have to do is define the `search` method\r\n```python\r\nclass SearchableItemResource(APIResource):\r\n    model = Item\r\n    name = 'searchable_item'\r\n    results_per_page = 20\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'id': item.id,\r\n            'text': item.text,\r\n            'popularity': item.popularity,\r\n        }\r\n\r\n    def search(self, get_params):\r\n        \"\"\"\r\n        Some custom search logic.\r\n        You always have access to the request.GET params\r\n        through `get_params`\r\n        \"\"\"\r\n        filter_kwargs = {}\r\n        if get_params.get(\"popular\"):\r\n            filter_kwargs[\"status__gte\"] = 9\r\n         \r\n        if get_params.get(\"contains\"):\r\n            filter_kwargs[\"text__icontains\"] = get_params[\"contains\"]\r\n        return self.get_queryset().filter(**filter_kwargs)\r\n```\r\n\r\nThe important thing here is you can plug in whatever search system you want. You're not even tied to SQL or the Django ORM. You can use ElasticSearch or whatever backend makes sense for your use case. You just have to define the `search` method that takes a dictionary of request GET params.\r\n\r\n#### Make a search request\r\nThe URL will be \"/{resource name}/search/\"\r\nThe format of the request will depend on how you implement the `search` method, but in this case, it looks like this:\r\n\r\n`GET /api/searchable_item/search/?popular=1&contains=fun`\r\n\r\n## Use Authentication<a name=\"use-authentication\">&nbsp;</a>\r\nEasyRest Authentication is really easy to use and extend, as you'll see below.\r\n\r\n#### 1. Define an authorization scheme\r\nDecide whether you want your API consumer to pass in an API key through the request GET parameters or the headers or whatever else.\r\n\r\n#### 2. Set `needs_authentication = True` in your resource declaration\r\n\r\n#### 3. Define an `authorize` method for your resource\r\nHere's an example:\r\n\r\n```python\r\nfrom resteasy import APIResource\r\nfrom resteasy.auth import get_user_from_GET_param\r\n\r\nclass AuthorizedItemResource(APIResource):\r\n    model = UserItem\r\n    name = 'authorized_item'\r\n    needs_authentication = True\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n\r\n    def authorize(self, request):\r\n        \"\"\"\r\n        I find the user based on the value of `apikey`\r\n        being passed in as a GET parameter.\r\n        \"\"\"\r\n        return get_user_from_GET_param(request, \"apikey\")\r\n```\r\n#### Advice on many resources sharing same authorization scheme\r\nOften you may want the same authorization method for many of your resources.\r\nIn that case, you should subclass APIResource.\r\n\r\nLet's call the new class AuthorizedAPIResource.\r\nDefine the `authorize` method of AuthorizedAPIResource and then have your model resources inherit from AuthorizedAPIResource\r\n\r\n#### What does an example request with authorization look like?\r\nThis will depend on authorization scheme, but in the above case where we pass in the apikey in the get request, it would look like this:\r\n```python\r\nGET /api/authorized_item/?apikey=kjhsdf3\r\n```\r\n\r\n## Authorization helpers<a name=\"authorization-helpers\">&nbsp;</a>\r\nIn easyrest.auth, there are three really useful helper methods:\r\n\r\n1. `get_user_from_GET_param(request, param_name)`: extracts API key from the request GET parameter `param_name` and returns the user who owns that API key.\r\n2. `get_user_from_from_request_header`: does the same but from the request header\r\n3. `get_user_from_request`: returns `request.user` if the user is authenticated\r\n\r\nThese are by no means exhaustive, but they do cover a lot of the ways in which you'll want you're API consumers to authenticate.\r\n\r\nIf you want to use your own way of authenticating, just write your own `authorize` method, and you're good.\r\n\r\n#### What happens if an unauthorized person tries to access a protected resource?\r\nIf someone tries to access a resource without authorization, they will get a 403 Forbidden response.\r\n\r\n## Restrict Results by User<a name=\"#restrict-results-by-user\">&nbsp;</a>\r\nA lot of the time, we want our API consumers to only access the results that they own.\r\n\r\nImagine an API you can use to get all your Bank Transactions. You want some way of limiting the API user to only retrieving their own bank transactions, so they don't have access to everyone's bank transactions.\r\n\r\nTo achieve this, you just need to do 1 thing in addition to setting up Authentication as above.\r\n#### Set `user_field_to_restrict_by`\r\nWhen you declare your resource, you should set `user_field_to_restrict_by` equal to the field path to the User field corresponding to the owner, the same path you would use through the Django Queryset API.\r\n\r\nIf your UserItem is linked to a User through the field \"user\", for example:\r\n```python\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    user = models.ForeignKey('auth.User')\r\n    is_active = models.BooleanField(default=False)\r\n```\r\nYou should set `user_field_to_restrict_by=\"user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    user_field_to_restrict_by = 'user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\nNow when someone makes an authorized request, the results will be limited to the results that they own, where the owner is defined by the `user_field_to_restrict_by` path.\r\n\r\n\r\n#### A more complicated example\r\n\r\n```python\r\nclass Profile(models.Model):\r\n    owner = models.ForeignKeyField('auth.User')\r\n\r\nclass UserItem(models.Model):\r\n    name = models.CharField(max_length=250)\r\n    profile = models.ForeignKeyField(Profile)\r\n    is_active = models.BooleanField(default=False)\r\n```\r\n\r\nYou should set `user_field_to_restrict_by=\"profile__user\"` as follows:\r\n```python\r\nclass AuthorizedItemResourceByUser(MyAuthenticatedResource):\r\n    model = UserItem\r\n    name = 'restrict_user_authorized_item'\r\n    needs_authentication = True\r\n    user_field_to_restrict_by = 'profile__user'\r\n\r\n    def serialize(self, item):\r\n        return {\r\n            'name': item.name,\r\n            'id': item.id,\r\n            'user_id': item.user.id,\r\n        }\r\n```\r\n\r\n# Bend EasyRest to Your Will<a name=\"bend-easyrest-to-your-will\">&nbsp;</a>\r\nHere are some facts.\r\n\r\n* EasyRest is 160 lines of code.\r\n* You may have custom needs for your API.\r\n* If you read the source code, you'll know how to extend EasyRest to suit your needs.\r\n\r\n#### My Recommendations\r\nWhether you want to change the url schema, add more CRUD methods, or change the way data is retrieved,\r\nalways feel free to subclass `easyrest.API`, `easyrest.APIResource`, and the `ListView` and `ItemView` to your heart's desire.\r\n\r\nLet me know how you extend EasyRest, I'd be excited to learn and potentially get some pull requests!\r\n\r\n# How to Hack on EasyRest<a name=\"how-to-hack-on-easyrest\">&nbsp;</a>\r\n1. git clone this repo\r\n2. create a virtualenv and install the requirements via `pip install -r requirements.txt`\r\n3. under /tests, run `python manage.py syncdb`\r\n4. to run the tests, in the root directory run `make test`\r\n\r\nHappy hacking!\r\n\r\n\r\n# Roadmap<a name=\"roadmap\">&nbsp;</a>\r\nI'm thinking about whether to support the other CRUD operations.\r\nIf you have any suggestions, please let me know.\r\n\r\n\r\n# License<a name=\"license\">&nbsp;</a>\r\n\r\n(The MIT license)\r\n\r\nCopyright (c) 2013 Suneel Chakravorty <suneel0101@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}